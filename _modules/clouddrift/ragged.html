
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>clouddrift.ragged &#8212; CloudDrift  documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=35a8b989"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/clouddrift/ragged';</script>
    <link rel="icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo.png" class="logo__image only-light" alt="CloudDrift  documentation - Home"/>
    <script>document.write(`<img src="../../_static/logo.png" class="logo__image only-dark" alt="CloudDrift  documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>

<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../datasets.html">Datasets</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Reference</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference external" href="https://github.com/Cloud-Drift/clouddrift/blob/main/CONTRIBUTING.md">Contributing</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../api.html">API</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.html">clouddrift.adapters</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.andro.html">clouddrift.adapters.andro</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.andro.to_xarray.html">clouddrift.adapters.andro.to_xarray</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.html">clouddrift.adapters.gdp</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.cast_float64_variables_to_float32.html">clouddrift.adapters.gdp.cast_float64_variables_to_float32</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.cut_str.html">clouddrift.adapters.gdp.cut_str</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.decode_date.html">clouddrift.adapters.gdp.decode_date</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.drogue_presence.html">clouddrift.adapters.gdp.drogue_presence</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.fetch_netcdf.html">clouddrift.adapters.gdp.fetch_netcdf</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.fill_values.html">clouddrift.adapters.gdp.fill_values</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.get_gdp_metadata.html">clouddrift.adapters.gdp.get_gdp_metadata</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.order_by_date.html">clouddrift.adapters.gdp.order_by_date</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.parse_directory_file.html">clouddrift.adapters.gdp.parse_directory_file</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.rowsize.html">clouddrift.adapters.gdp.rowsize</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.str_to_float.html">clouddrift.adapters.gdp.str_to_float</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.gdp1h.html">clouddrift.adapters.gdp.gdp1h</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.gdp6h.html">clouddrift.adapters.gdp.gdp6h</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.gdp.gdpsource.html">clouddrift.adapters.gdp.gdpsource</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.glad.html">clouddrift.adapters.glad</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.glad.get_dataframe.html">clouddrift.adapters.glad.get_dataframe</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.glad.to_xarray.html">clouddrift.adapters.glad.to_xarray</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.hurdat2.html">clouddrift.adapters.hurdat2</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.hurdat2.to_raggedarray.html">clouddrift.adapters.hurdat2.to_raggedarray</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.hurdat2.DataLine.html">clouddrift.adapters.hurdat2.DataLine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.hurdat2.HeaderLine.html">clouddrift.adapters.hurdat2.HeaderLine</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.hurdat2.RecordIdentifier.html">clouddrift.adapters.hurdat2.RecordIdentifier</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.hurdat2.SystemStatus.html">clouddrift.adapters.hurdat2.SystemStatus</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.hurdat2.TrackData.html">clouddrift.adapters.hurdat2.TrackData</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.ibtracs.html">clouddrift.adapters.ibtracs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.ibtracs.to_raggedarray.html">clouddrift.adapters.ibtracs.to_raggedarray</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.mosaic.html">clouddrift.adapters.mosaic</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.mosaic.get_dataframes.html">clouddrift.adapters.mosaic.get_dataframes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.mosaic.get_file_urls.html">clouddrift.adapters.mosaic.get_file_urls</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.mosaic.get_repository_metadata.html">clouddrift.adapters.mosaic.get_repository_metadata</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.mosaic.to_xarray.html">clouddrift.adapters.mosaic.to_xarray</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.subsurface_floats.html">clouddrift.adapters.subsurface_floats</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.subsurface_floats.download.html">clouddrift.adapters.subsurface_floats.download</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.subsurface_floats.to_xarray.html">clouddrift.adapters.subsurface_floats.to_xarray</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.utils.html">clouddrift.adapters.utils</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.utils.download_with_progress.html">clouddrift.adapters.utils.download_with_progress</a></li>
</ul>
</details></li>
<li class="toctree-l3 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.yomaha.html">clouddrift.adapters.yomaha</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.yomaha.download.html">clouddrift.adapters.yomaha.download</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../_autosummary/clouddrift.adapters.yomaha.to_xarray.html">clouddrift.adapters.yomaha.to_xarray</a></li>
</ul>
</details></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.html">clouddrift.datasets</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.andro.html">clouddrift.datasets.andro</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.gdp1h.html">clouddrift.datasets.gdp1h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.gdp6h.html">clouddrift.datasets.gdp6h</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.gdp_source.html">clouddrift.datasets.gdp_source</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.glad.html">clouddrift.datasets.glad</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.hurdat2.html">clouddrift.datasets.hurdat2</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.ibtracs.html">clouddrift.datasets.ibtracs</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.mosaic.html">clouddrift.datasets.mosaic</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.spotters.html">clouddrift.datasets.spotters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.subsurface_floats.html">clouddrift.datasets.subsurface_floats</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.datasets.yomaha.html">clouddrift.datasets.yomaha</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.kinematics.html">clouddrift.kinematics</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.kinematics.inertial_oscillation_from_position.html">clouddrift.kinematics.inertial_oscillation_from_position</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.kinematics.kinetic_energy.html">clouddrift.kinematics.kinetic_energy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.kinematics.position_from_velocity.html">clouddrift.kinematics.position_from_velocity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.kinematics.residual_position_from_displacement.html">clouddrift.kinematics.residual_position_from_displacement</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.kinematics.spin.html">clouddrift.kinematics.spin</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.kinematics.velocity_from_position.html">clouddrift.kinematics.velocity_from_position</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.pairs.html">clouddrift.pairs</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.pairs.chance_pair.html">clouddrift.pairs.chance_pair</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.pairs.chance_pairs_from_ragged.html">clouddrift.pairs.chance_pairs_from_ragged</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.pairs.pair_bounding_box_overlap.html">clouddrift.pairs.pair_bounding_box_overlap</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.pairs.pair_space_distance.html">clouddrift.pairs.pair_space_distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.pairs.pair_time_distance.html">clouddrift.pairs.pair_time_distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.pairs.pair_time_overlap.html">clouddrift.pairs.pair_time_overlap</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.plotting.html">clouddrift.plotting</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.plotting.plot_ragged.html">clouddrift.plotting.plot_ragged</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.html">clouddrift.ragged</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.apply_ragged.html">clouddrift.ragged.apply_ragged</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.chunk.html">clouddrift.ragged.chunk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.obs_index_to_row.html">clouddrift.ragged.obs_index_to_row</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.prune.html">clouddrift.ragged.prune</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.ragged_to_regular.html">clouddrift.ragged.ragged_to_regular</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.regular_to_ragged.html">clouddrift.ragged.regular_to_ragged</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.rowsize_to_index.html">clouddrift.ragged.rowsize_to_index</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.segment.html">clouddrift.ragged.segment</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.subset.html">clouddrift.ragged.subset</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.ragged.unpack.html">clouddrift.ragged.unpack</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.raggedarray.html">clouddrift.raggedarray</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.raggedarray.RaggedArray.html">clouddrift.raggedarray.RaggedArray</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.signal.html">clouddrift.signal</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.signal.analytic_signal.html">clouddrift.signal.analytic_signal</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.signal.cartesian_to_rotary.html">clouddrift.signal.cartesian_to_rotary</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.signal.ellipse_parameters.html">clouddrift.signal.ellipse_parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.signal.modulated_ellipse_signal.html">clouddrift.signal.modulated_ellipse_signal</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.signal.rotary_to_cartesian.html">clouddrift.signal.rotary_to_cartesian</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.html">clouddrift.sphere</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.bearing.html">clouddrift.sphere.bearing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.cartesian_to_spherical.html">clouddrift.sphere.cartesian_to_spherical</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.cartesian_to_tangentplane.html">clouddrift.sphere.cartesian_to_tangentplane</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.coriolis_frequency.html">clouddrift.sphere.coriolis_frequency</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.cumulative_distance.html">clouddrift.sphere.cumulative_distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.distance.html">clouddrift.sphere.distance</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.plane_to_sphere.html">clouddrift.sphere.plane_to_sphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.position_from_distance_and_bearing.html">clouddrift.sphere.position_from_distance_and_bearing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.recast_lon.html">clouddrift.sphere.recast_lon</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.recast_lon180.html">clouddrift.sphere.recast_lon180</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.recast_lon360.html">clouddrift.sphere.recast_lon360</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.sphere_to_plane.html">clouddrift.sphere.sphere_to_plane</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.spherical_to_cartesian.html">clouddrift.sphere.spherical_to_cartesian</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.sphere.tangentplane_to_cartesian.html">clouddrift.sphere.tangentplane_to_cartesian</a></li>
</ul>
</details></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../_autosummary/clouddrift.wavelet.html">clouddrift.wavelet</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.wavelet.morse_amplitude.html">clouddrift.wavelet.morse_amplitude</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.wavelet.morse_freq.html">clouddrift.wavelet.morse_freq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.wavelet.morse_logspace_freq.html">clouddrift.wavelet.morse_logspace_freq</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.wavelet.morse_properties.html">clouddrift.wavelet.morse_properties</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.wavelet.morse_wavelet.html">clouddrift.wavelet.morse_wavelet</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.wavelet.morse_wavelet_transform.html">clouddrift.wavelet.morse_wavelet_transform</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../_autosummary/clouddrift.wavelet.wavelet_transform.html">clouddrift.wavelet.wavelet_transform</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for clouddrift.ragged</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Transformational and inquiry functions for ragged arrays.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Iterable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">concurrent</span><span class="w"> </span><span class="kn">import</span> <span class="n">futures</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">timedelta</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>


<div class="viewcode-block" id="apply_ragged">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.apply_ragged.html#clouddrift.ragged.apply_ragged">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">apply_ragged</span><span class="p">(</span>
    <span class="n">func</span><span class="p">:</span> <span class="nb">callable</span><span class="p">,</span>
    <span class="n">arrays</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">rowsize</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span>
    <span class="n">rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">executor</span><span class="p">:</span> <span class="n">futures</span><span class="o">.</span><span class="n">Executor</span> <span class="o">=</span> <span class="n">futures</span><span class="o">.</span><span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply a function to a ragged array.</span>

<span class="sd">    The function ``func`` will be applied to each contiguous row of ``arrays`` as</span>
<span class="sd">    indicated by row sizes ``rowsize``. The output of ``func`` will be</span>
<span class="sd">    concatenated into a single ragged array.</span>

<span class="sd">    You can pass ``arrays`` as NumPy arrays or xarray DataArrays, however,</span>
<span class="sd">    the result will always be a NumPy array. Passing ``rows`` as an integer or</span>
<span class="sd">    a sequence of integers will make ``apply_ragged`` process and return only</span>
<span class="sd">    those specific rows, and otherwise, all rows in the input ragged array will</span>
<span class="sd">    be processed. Further, you can use the ``axis`` parameter to specify the</span>
<span class="sd">    ragged axis of the input array(s) (default is 0).</span>

<span class="sd">    By default this function uses ``concurrent.futures.ThreadPoolExecutor`` to</span>
<span class="sd">    run ``func`` in multiple threads. The number of threads can be controlled by</span>
<span class="sd">    passing the ``max_workers`` argument to the executor instance passed to</span>
<span class="sd">    ``apply_ragged``. Alternatively, you can pass the ``concurrent.futures.ProcessPoolExecutor``</span>
<span class="sd">    instance to use processes instead. Passing alternative (3rd party library)</span>
<span class="sd">    concurrent executors may work if they follow the same executor interface as</span>
<span class="sd">    that of ``concurrent.futures``, however this has not been tested yet.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    func : callable</span>
<span class="sd">        Function to apply to each row of each ragged array in ``arrays``.</span>
<span class="sd">    arrays : list[np.ndarray] or np.ndarray or xr.DataArray</span>
<span class="sd">        An array or a list of arrays to apply ``func`` to.</span>
<span class="sd">    rowsize : list[int] or np.ndarray[int] or xr.DataArray[int]</span>
<span class="sd">        List of integers specifying the number of data points in each row.</span>
<span class="sd">    *args : tuple</span>
<span class="sd">        Additional arguments to pass to ``func``.</span>
<span class="sd">    rows : int or Iterable[int], optional</span>
<span class="sd">        The row(s) of the ragged array to apply ``func`` to. If ``rows`` is</span>
<span class="sd">        ``None`` (default), then ``func`` will be applied to all rows.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The ragged axis of the input arrays. Default is 0.</span>
<span class="sd">    executor : concurrent.futures.Executor, optional</span>
<span class="sd">        Executor to use for concurrent execution. Default is ``ThreadPoolExecutor``</span>
<span class="sd">        with the default number of ``max_workers``.</span>
<span class="sd">        Another supported option is ``ProcessPoolExecutor``.</span>
<span class="sd">    **kwargs : dict</span>
<span class="sd">        Additional keyword arguments to pass to ``func``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : tuple[np.ndarray] or np.ndarray</span>
<span class="sd">        Output array(s) from ``func``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Using ``velocity_from_position`` with ``apply_ragged``, calculate the velocities of</span>
<span class="sd">    multiple particles, the coordinates of which are found in the ragged arrays x, y, and t</span>
<span class="sd">    that share row sizes 2, 3, and 4:</span>

<span class="sd">    &gt;&gt;&gt; from clouddrift.kinematics import velocity_from_position</span>
<span class="sd">    &gt;&gt;&gt; rowsize = [2, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 10, 12, 14, 30, 33, 36, 39])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8])</span>
<span class="sd">    &gt;&gt;&gt; t = np.array([1, 2, 1, 2, 3, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; u1, v1 = apply_ragged(velocity_from_position, [x, y, t], rowsize, coord_system=&quot;cartesian&quot;)</span>
<span class="sd">    &gt;&gt;&gt; u1</span>
<span class="sd">    array([1., 1., 2., 2., 2., 3., 3., 3., 3.])</span>
<span class="sd">    &gt;&gt;&gt; v1</span>
<span class="sd">    array([1., 1., 1., 1., 1., 1., 1., 1., 1.])</span>

<span class="sd">    To apply ``func`` to only a subset of rows, use the ``rows`` argument:</span>

<span class="sd">    &gt;&gt;&gt; u1, v1 = apply_ragged(velocity_from_position, [x, y, t], rowsize, rows=0, coord_system=&quot;cartesian&quot;)</span>
<span class="sd">    &gt;&gt;&gt; u1</span>
<span class="sd">    array([1., 1.])</span>
<span class="sd">    &gt;&gt;&gt; v1</span>
<span class="sd">    array([1., 1.])</span>
<span class="sd">    &gt;&gt;&gt; u1, v1 = apply_ragged(velocity_from_position, [x, y, t], rowsize, rows=[0, 1], coord_system=&quot;cartesian&quot;)</span>
<span class="sd">    &gt;&gt;&gt; u1</span>
<span class="sd">    array([1., 1., 2., 2., 2.])</span>
<span class="sd">    &gt;&gt;&gt; v1</span>
<span class="sd">    array([1., 1., 1., 1., 1.])</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the sum of ``rowsize`` does not equal the length of ``arrays``.</span>
<span class="sd">    IndexError</span>
<span class="sd">        If empty ``arrays``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># make sure the arrays is iterable</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">arrays</span><span class="p">]</span>
    <span class="c1"># validate rowsize</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rowsize</span><span class="p">)</span> <span class="o">==</span> <span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sum of rowsize must equal the length of arr.&quot;</span><span class="p">)</span>

    <span class="c1"># split the array(s) into rows</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">unpack</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="n">rowsize</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
    <span class="nb">iter</span> <span class="o">=</span> <span class="p">[[</span><span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">))]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]))]</span>

    <span class="c1"># parallel execution</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">]</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>

    <span class="c1"># Concatenate the outputs.</span>

    <span class="c1"># The following wraps items in a list if they are not already iterable.</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">item</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>

    <span class="c1"># np.concatenate can concatenate along non-zero axis iff the length of</span>
    <span class="c1"># arrays to be concatenated is &gt; 1. If the length is 1, for example in the</span>
    <span class="c1"># case of func that reduces over the non-ragged axis, we can only</span>
    <span class="c1"># concatenate along axis 0.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># more than 1 parameter</span>
        <span class="n">outputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>  <span class="c1"># iterate over each result variable</span>
            <span class="c1"># If we have multiple outputs and func is a reduction function,</span>
            <span class="c1"># we now here have a list of scalars. We need to wrap them in a</span>
            <span class="c1"># list to concatenate them.</span>
            <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Iterable</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Arrays to concatenate are longer than 1 element, so we can</span>
                <span class="c1"># concatenate along the non-zero axis.</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Arrays to concatenate are 1 element long, so we can only</span>
                <span class="c1"># concatenate along axis 0.</span>
                <span class="n">outputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">outputs</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Arrays to concatenate are longer than 1 element, so we can</span>
            <span class="c1"># concatenate along the non-zero axis.</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Arrays to concatenate are 1 element long, so we can only</span>
            <span class="c1"># concatenate along axis 0.</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>



<div class="viewcode-block" id="chunk">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.chunk.html#clouddrift.ragged.chunk">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">chunk</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">,</span>
    <span class="n">length</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">overlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">align</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Divide an array ``x`` into equal chunks of length ``length``. The result</span>
<span class="sd">    is a 2-dimensional NumPy array of shape ``(num_chunks, length)``. The resulting</span>
<span class="sd">    number of chunks is determined based on the length of ``x``, ``length``,</span>
<span class="sd">    and ``overlap``.</span>

<span class="sd">    ``chunk`` can be combined with :func:`apply_ragged` to chunk a ragged array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : list or array-like</span>
<span class="sd">        Array to divide into chunks.</span>
<span class="sd">    length : int</span>
<span class="sd">        The length of each chunk.</span>
<span class="sd">    overlap : int, optional</span>
<span class="sd">        The number of overlapping array elements across chunks. The default is 0.</span>
<span class="sd">        Must be smaller than ``length``. For example, if ``length`` is 4 and</span>
<span class="sd">        ``overlap`` is 2, the chunks of ``[0, 1, 2, 3, 4, 5]`` will be</span>
<span class="sd">        ``np.array([[0, 1, 2, 3], [2, 3, 4, 5]])``. Negative overlap can be used</span>
<span class="sd">        to offset chunks by some number of elements. For example, if ``length``</span>
<span class="sd">        is 2 and ``overlap`` is -1, the chunks of ``[0, 1, 2, 3, 4, 5]`` will</span>
<span class="sd">        be ``np.array([[0, 1], [3, 4]])``.</span>
<span class="sd">    align : str, optional [&quot;start&quot;, &quot;middle&quot;, &quot;end&quot;]</span>
<span class="sd">        If the remainder of the length of ``x`` divided by the chunk ``length`` is a number</span>
<span class="sd">        N different from zero, this parameter controls which part of the array will be kept</span>
<span class="sd">        into the chunks. If ``align=&quot;start&quot;``, the elements at the beginning of the array</span>
<span class="sd">        will be part of the chunks and N points are discarded at the end. If `align=&quot;middle&quot;`,</span>
<span class="sd">        floor(N/2) and ceil(N/2) elements will be discarded from the beginning and the end</span>
<span class="sd">        of the array, respectively. If ``align=&quot;end&quot;``, the elements at the end of the array</span>
<span class="sd">        will be kept, and the `N` first elements are discarded. The default is &quot;start&quot;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        2-dimensional array of shape ``(num_chunks, length)``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Chunk a simple list; this discards the end elements that exceed the last chunk:</span>

<span class="sd">    &gt;&gt;&gt; chunk([1, 2, 3, 4, 5], 2)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    To discard the starting elements of the array instead, use ``align=&quot;end&quot;``:</span>

<span class="sd">    &gt;&gt;&gt; chunk([1, 2, 3, 4, 5], 2, align=&quot;end&quot;)</span>
<span class="sd">    array([[2, 3],</span>
<span class="sd">           [4, 5]])</span>

<span class="sd">    To center the chunks by discarding both ends of the array, use ``align=&quot;middle&quot;``:</span>

<span class="sd">    &gt;&gt;&gt; chunk([1, 2, 3, 4, 5, 6, 7, 8], 3, align=&quot;middle&quot;)</span>
<span class="sd">    array([[2, 3, 4],</span>
<span class="sd">           [5, 6, 7]])</span>

<span class="sd">    Specify ``overlap`` to get overlapping chunks:</span>

<span class="sd">    &gt;&gt;&gt; chunk([1, 2, 3, 4, 5], 2, overlap=1)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [2, 3],</span>
<span class="sd">           [3, 4],</span>
<span class="sd">           [4, 5]])</span>

<span class="sd">    Use ``apply_ragged`` to chunk a ragged array by providing the row sizes;</span>
<span class="sd">    notice that you must pass the array to chunk as an array-like, not a list:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; rowsize = [2, 1, 2]</span>
<span class="sd">    &gt;&gt;&gt; apply_ragged(chunk, x, rowsize, 2)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [4, 5]])</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``length &lt; 0``.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If ``align not in [&quot;start&quot;, &quot;middle&quot;, &quot;end&quot;]``.</span>
<span class="sd">    ZeroDivisionError</span>
<span class="sd">        if ``length == 0``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">num_chunks</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">length</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">length</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">length</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">remainder</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">num_chunks</span> <span class="o">*</span> <span class="n">length</span> <span class="o">+</span> <span class="p">(</span><span class="n">num_chunks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">overlap</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">num_chunks</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">align</span> <span class="o">==</span> <span class="s2">&quot;start&quot;</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s2">&quot;middle&quot;</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">remainder</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">align</span> <span class="o">==</span> <span class="s2">&quot;end&quot;</span><span class="p">:</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">remainder</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;align must be one of &#39;start&#39;, &#39;middle&#39;, or &#39;end&#39;.&quot;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span>
        <span class="n">res</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">overlap</span>

    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="prune">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.prune.html#clouddrift.ragged.prune">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">prune</span><span class="p">(</span>
    <span class="n">ragged</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">rowsize</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">min_rowsize</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Within a ragged array, removes arrays less than a specified row size.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ragged : np.ndarray or pd.Series or xr.DataArray</span>
<span class="sd">        A ragged array.</span>
<span class="sd">    rowsize : list or np.ndarray[int] or pd.Series or xr.DataArray[int]</span>
<span class="sd">        The size of each row in the input ragged array.</span>
<span class="sd">    min_rowsize :</span>
<span class="sd">        The minimum row size that will be kept.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[np.ndarray, np.ndarray]</span>
<span class="sd">        A tuple of ragged array and size of each row.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from clouddrift.ragged import prune</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; prune(np.array([1, 2, 3, 0, -1, -2]), np.array([3, 1, 2]),2)</span>
<span class="sd">    (array([ 1,  2,  3, -1, -2]), array([3, 2]))</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the sum of ``rowsize`` does not equal the length of ``arrays``.</span>
<span class="sd">    IndexError</span>
<span class="sd">        If empty ``ragged``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`segment`, `chunk`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ragged</span> <span class="o">=</span> <span class="n">apply_ragged</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">min_len</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_len</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ragged</span><span class="p">),</span>
        <span class="n">rowsize</span><span class="p">,</span>
        <span class="n">min_len</span><span class="o">=</span><span class="n">min_rowsize</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">rowsize</span> <span class="o">=</span> <span class="n">apply_ragged</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">min_len</span><span class="p">:</span> <span class="n">x</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">min_len</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rowsize</span><span class="p">),</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">rowsize</span><span class="p">),</span>
        <span class="n">min_len</span><span class="o">=</span><span class="n">min_rowsize</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ragged</span><span class="p">,</span> <span class="n">rowsize</span></div>



<div class="viewcode-block" id="ragged_to_regular">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.ragged_to_regular.html#clouddrift.ragged.ragged_to_regular">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ragged_to_regular</span><span class="p">(</span>
    <span class="n">ragged</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">rowsize</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a ragged array to a two-dimensional array such that each contiguous segment</span>
<span class="sd">    of a ragged array is a row in the two-dimensional array. Each row of the two-dimensional</span>
<span class="sd">    array is padded with NaNs as needed. The length of the first dimension of the output</span>
<span class="sd">    array is the length of ``rowsize``. The length of the second dimension is the maximum</span>
<span class="sd">    element of ``rowsize``.</span>

<span class="sd">    Note: Although this function accepts parameters of type ``xarray.DataArray``,</span>
<span class="sd">    passing NumPy arrays is recommended for performance reasons.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ragged : np.ndarray or pd.Series or xr.DataArray</span>
<span class="sd">        A ragged array.</span>
<span class="sd">    rowsize : list or np.ndarray[int] or pd.Series or xr.DataArray[int]</span>
<span class="sd">        The size of each row in the ragged array.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        Fill value to use for the trailing elements of each row of the resulting</span>
<span class="sd">        regular array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A two-dimensional array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    By default, the fill value used is NaN:</span>

<span class="sd">    &gt;&gt;&gt; ragged_to_regular(np.array([1, 2, 3, 4, 5]), np.array([2, 1, 2]))</span>
<span class="sd">    array([[ 1.,  2.],</span>
<span class="sd">           [ 3., nan],</span>
<span class="sd">           [ 4.,  5.]])</span>

<span class="sd">    You can specify an alternative fill value:</span>

<span class="sd">    &gt;&gt;&gt; ragged_to_regular(np.array([1, 2, 3, 4, 5]), np.array([2, 1, 2]), fill_value=999)</span>
<span class="sd">    array([[  1,   2],</span>
<span class="sd">           [  3, 999],</span>
<span class="sd">           [  4,   5]])</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`regular_to_ragged`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">fill_value</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rowsize</span><span class="p">),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">rowsize</span><span class="p">))),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ragged</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">unpacked</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="n">ragged</span><span class="p">,</span> <span class="n">rowsize</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rowsize</span><span class="p">)):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">n</span><span class="p">,</span> <span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">rowsize</span><span class="p">[</span><span class="n">n</span><span class="p">])]</span> <span class="o">=</span> <span class="n">unpacked</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span></div>



<div class="viewcode-block" id="regular_to_ragged">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.regular_to_ragged.html#clouddrift.ragged.regular_to_ragged">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">regular_to_ragged</span><span class="p">(</span>
    <span class="n">array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a two-dimensional array to a ragged array. Fill values in the input array are</span>
<span class="sd">    excluded from the output ragged array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : np.ndarray</span>
<span class="sd">        A two-dimensional array.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        Fill value used to determine the bounds of contiguous segments.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple[np.ndarray, np.ndarray]</span>
<span class="sd">        A tuple of the ragged array and the size of each row.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    By default, NaN values found in the input regular array are excluded from</span>
<span class="sd">    the output ragged array:</span>

<span class="sd">    &gt;&gt;&gt; regular_to_ragged(np.array([[1, 2], [3, np.nan], [4, 5]]))</span>
<span class="sd">    (array([1., 2., 3., 4., 5.]), array([2, 1, 2]))</span>

<span class="sd">    Alternatively, a different fill value can be specified:</span>

<span class="sd">    &gt;&gt;&gt; regular_to_ragged(np.array([[1, 2], [3, -999], [4, 5]]), fill_value=-999)</span>
<span class="sd">    (array([1, 2, 3, 4, 5]), array([2, 1, 2]))</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`ragged_to_regular`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fill_value</span><span class="p">):</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">valid</span> <span class="o">=</span> <span class="n">array</span> <span class="o">!=</span> <span class="n">fill_value</span>
    <span class="k">return</span> <span class="n">array</span><span class="p">[</span><span class="n">valid</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">valid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="rowsize_to_index">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.rowsize_to_index.html#clouddrift.ragged.rowsize_to_index">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">rowsize_to_index</span><span class="p">(</span><span class="n">rowsize</span><span class="p">:</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a list of row sizes to a list of indices.</span>

<span class="sd">    This function is typically used to obtain the indices of data rows organized</span>
<span class="sd">    in a ragged array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rowsize : list or np.ndarray or xr.DataArray</span>
<span class="sd">        A list of row sizes.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray</span>
<span class="sd">        A list of indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To obtain the indices within a ragged array of three consecutive rows of sizes 100, 202, and 53:</span>

<span class="sd">    &gt;&gt;&gt; rowsize_to_index([100, 202, 53])</span>
<span class="sd">    array([  0, 100, 302, 355])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rowsize</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span></div>



<div class="viewcode-block" id="segment">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.segment.html#clouddrift.ragged.segment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">segment</span><span class="p">(</span>
    <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
    <span class="n">tolerance</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span> <span class="o">|</span> <span class="n">timedelta</span> <span class="o">|</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">,</span>
    <span class="n">rowsize</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Divide an array into segments based on a tolerance value.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : list, np.ndarray, or xr.DataArray</span>
<span class="sd">        An array to divide into segment.</span>
<span class="sd">    tolerance : float, np.timedelta64, timedelta, pd.Timedelta</span>
<span class="sd">        The maximum signed difference between consecutive points in a segment.</span>
<span class="sd">        The array x will be segmented wherever differences exceed the tolerance.</span>
<span class="sd">    rowsize : np.ndarray[int], optional</span>
<span class="sd">        The size of rows if x is originally a ragged array. If present, x will be</span>
<span class="sd">        divided both by gaps that exceed the tolerance, and by the original rows</span>
<span class="sd">        of the ragged array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    np.ndarray[int]</span>
<span class="sd">        An array of row sizes that divides the input array into segments.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The simplest use of ``segment`` is to provide a tolerance value that is</span>
<span class="sd">    used to divide an array into segments:</span>
<span class="sd">    &gt;&gt;&gt; from clouddrift.ragged import segment, subset</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; x = [0, 1, 1, 1, 2, 2, 3, 3, 3, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; segment(x, 0.5)</span>
<span class="sd">    array([1, 3, 2, 4, 1])</span>

<span class="sd">    If the array is already previously segmented (e.g. multiple rows in</span>
<span class="sd">    a ragged array), then the ``rowsize`` argument can be used to preserve</span>
<span class="sd">    the original segments:</span>

<span class="sd">    &gt;&gt;&gt; x = [0, 1, 1, 1, 2, 2, 3, 3, 3, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; rowsize = [3, 2, 6]</span>
<span class="sd">    &gt;&gt;&gt; segment(x, 0.5, rowsize)</span>
<span class="sd">    array([1, 2, 1, 1, 1, 4, 1])</span>

<span class="sd">    The tolerance can also be negative. In this case, the input array is</span>
<span class="sd">    segmented where the negative difference exceeds the negative</span>
<span class="sd">    value of the tolerance, i.e. where ``x[n+1] - x[n] &lt; -tolerance``:</span>

<span class="sd">    &gt;&gt;&gt; x = [0, 1, 2, 0, 1, 2]</span>
<span class="sd">    &gt;&gt;&gt; segment(x, -0.5)</span>
<span class="sd">    array([3, 3])</span>

<span class="sd">    To segment an array for both positive and negative gaps, invoke the function</span>
<span class="sd">    twice, once for a positive tolerance and once for a negative tolerance.</span>
<span class="sd">    The result of the first invocation can be passed as the ``rowsize`` argument</span>
<span class="sd">    to the first ``segment`` invocation:</span>

<span class="sd">    &gt;&gt;&gt; x = [1, 1, 2, 2, 1, 1, 2, 2]</span>
<span class="sd">    &gt;&gt;&gt; segment(x, 0.5, rowsize=segment(x, -0.5))</span>
<span class="sd">    array([2, 2, 2, 2])</span>

<span class="sd">    If the input array contains time objects, the tolerance must be a time interval:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([np.datetime64(&quot;2023-01-01&quot;), np.datetime64(&quot;2023-01-02&quot;),</span>
<span class="sd">    ...               np.datetime64(&quot;2023-01-03&quot;), np.datetime64(&quot;2023-02-01&quot;),</span>
<span class="sd">    ...               np.datetime64(&quot;2023-02-02&quot;)])</span>
<span class="sd">    &gt;&gt;&gt; segment(x, np.timedelta64(1, &quot;D&quot;))</span>
<span class="sd">    array([3, 2])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># for compatibility with datetime list or np.timedelta64 arrays</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">,</span> <span class="n">timedelta</span><span class="p">)):</span>
        <span class="n">tolerance</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">tolerance</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tolerance</span><span class="p">,</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">):</span>
        <span class="n">positive_tol</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="o">&gt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="s2">&quot;0 seconds&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">positive_tol</span> <span class="o">=</span> <span class="n">tolerance</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">rowsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">positive_tol</span><span class="p">:</span>
            <span class="n">exceeds_tolerance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">tolerance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">exceeds_tolerance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tolerance</span>
        <span class="n">segment_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">exceeds_tolerance</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">segment_sizes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment_sizes</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">segment_sizes</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">segment_sizes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rowsize</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The sum of rowsize must equal the length of x.&quot;</span><span class="p">)</span>
        <span class="n">segment_sizes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rowsize</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">segment_sizes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">],</span> <span class="n">tolerance</span><span class="p">))</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">end</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">segment_sizes</span><span class="p">)</span></div>



<div class="viewcode-block" id="subset">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.subset.html#clouddrift.ragged.subset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">subset</span><span class="p">(</span>
    <span class="n">ds</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">,</span>
    <span class="n">criteria</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
    <span class="n">id_var_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span>
    <span class="n">rowsize_var_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rowsize&quot;</span><span class="p">,</span>
    <span class="n">row_dim_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rows&quot;</span><span class="p">,</span>
    <span class="n">obs_dim_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;obs&quot;</span><span class="p">,</span>
    <span class="n">full_rows</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Subset a ragged array xarray dataset as a function of one or more criteria.</span>
<span class="sd">    The criteria are passed with a dictionary, where a dictionary key</span>
<span class="sd">    is a variable to subset and the associated dictionary value is either a range</span>
<span class="sd">    (valuemin, valuemax), a list [value1, value2, valueN], a single value, or a</span>
<span class="sd">    masking function applied to any variable of the dataset.</span>

<span class="sd">    This function needs to know the names of the dimensions of the ragged array dataset</span>
<span class="sd">    (`row_dim_name` and `obs_dim_name`), and the name of the rowsize variable (`rowsize_var_name`).</span>
<span class="sd">    Default values corresponds to the clouddrift convention (&quot;rows&quot;, &quot;obs&quot;, and &quot;rowsize&quot;) but should</span>
<span class="sd">    be changed as needed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ds : xr.Dataset</span>
<span class="sd">        Xarray dataset composed of ragged arrays.</span>
<span class="sd">    criteria : dict</span>
<span class="sd">        Dictionary containing the variables (as keys) and the ranges/values/functions (as values) to subset.</span>
<span class="sd">    id_var_name : str, optional</span>
<span class="sd">        Name of the variable with dimension `row_dim_name` containing the identification number of the</span>
<span class="sd">        rows (default is &quot;id&quot;).</span>
<span class="sd">    rowsize_var_name : str, optional</span>
<span class="sd">        Name of the variable containing the number of observations per row (default is &quot;rowsize&quot;).</span>
<span class="sd">    row_dim_name : str, optional</span>
<span class="sd">        Name of the row dimension (default is &quot;rows&quot;).</span>
<span class="sd">    obs_dim_name : str, optional</span>
<span class="sd">        Name of the observation dimension (default is &quot;obs&quot;).</span>
<span class="sd">    full_rows : bool, optional</span>
<span class="sd">        If True, the function returns complete rows for which the criteria</span>
<span class="sd">        are matched at least once. Default is False which means that only segments matching the criteria</span>
<span class="sd">        are returned when filtering along the observation dimension.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xr.Dataset</span>
<span class="sd">        Subset xarray dataset matching the criterion(a).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Criteria are combined on any data (with dimension &quot;obs&quot;) or metadata (with dimension &quot;rows&quot;) variables</span>
<span class="sd">    part of the Dataset. The following examples are based on NOAA GDP datasets which can be accessed with the</span>
<span class="sd">    ``clouddrift.datasets`` module. In these datasets, each row of the ragged arrays corresponds to the data from</span>
<span class="sd">    a single drifter trajectory and the `row_dim_name` is &quot;traj&quot; and the `obs_dim_name` is &quot;obs&quot;.</span>

<span class="sd">    Retrieve a region, like the Gulf of Mexico, using ranges of latitude and longitude:</span>
<span class="sd">    &gt;&gt;&gt; from clouddrift.datasets import gdp6h</span>
<span class="sd">    &gt;&gt;&gt; from clouddrift.ragged import subset</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    &gt;&gt;&gt; ds = gdp6h()</span>
<span class="sd">    ...</span>

<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;lat&quot;: (21, 31), &quot;lon&quot;: (-98, -78)}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    The parameter `full_rows` can be used to retrieve trajectories passing through a region, for example all trajectories passing through the Gulf of Mexico:</span>

<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;lat&quot;: (21, 31), &quot;lon&quot;: (-98, -78)}, full_rows=True, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    Retrieve drogued trajectory segments:</span>

<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;drogue_status&quot;: True}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    Dimensions:                (traj: ..., obs: ...)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">        id                     (traj) int64 ...</span>
<span class="sd">        time                   (obs) datetime64[ns] ...</span>
<span class="sd">    ...</span>

<span class="sd">    Retrieve trajectory segments with temperature higher than 25°C (303.15K):</span>

<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;temp&quot;: (303.15, np.inf)}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    You can use the same approach to return only the trajectories that are</span>
<span class="sd">    shorter than some number of observations (similar to :func:`prune` but for</span>
<span class="sd">    the entire dataset):</span>

<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;rowsize&quot;: (0, 1000)}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    Retrieve specific drifters using their IDs:</span>

<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;id&quot;: [2578, 2582, 2583]}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    Sometimes, you may want to retrieve specific rows of a ragged array.</span>
<span class="sd">    You can do that by filtering along the trajectory dimension directly, since</span>
<span class="sd">    this one corresponds to row numbers:</span>

<span class="sd">    &gt;&gt;&gt; rows = [5, 6, 7]</span>
<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;traj&quot;: rows}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    Retrieve a specific time period:</span>

<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;time&quot;: (np.datetime64(&quot;2000-01-01&quot;), np.datetime64(&quot;2020-01-31&quot;))}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    Note that to subset time variable, the range has to be defined as a function</span>
<span class="sd">    type of the variable. By default, ``xarray`` uses ``np.datetime64`` to</span>
<span class="sd">    represent datetime data. If the datetime data is a ``datetime.datetime``, or</span>
<span class="sd">    ``pd.Timestamp``, the range would have to be defined accordingly.</span>

<span class="sd">    Those criteria can also be combined:</span>

<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;lat&quot;: (21, 31), &quot;lon&quot;: (-98, -78), &quot;drogue_status&quot;: True, &quot;temp&quot;: (303.15, np.inf), &quot;time&quot;: (np.datetime64(&quot;2000-01-01&quot;), np.datetime64(&quot;2020-01-31&quot;))}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    You can also use a function to filter the data. For example, retrieve every other observation</span>
<span class="sd">    of each trajectory:</span>

<span class="sd">    &gt;&gt;&gt; func = (lambda arr: ((arr - arr[0]) % 2) == 0)</span>
<span class="sd">    &gt;&gt;&gt; subset(ds, {&quot;id&quot;: func}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; ...</span>
<span class="sd">    ...</span>

<span class="sd">    The filtering function can accept several input variables passed as a tuple. For example, retrieve</span>
<span class="sd">    drifters released in the Mediterranean Sea, but exclude those released in the Bay of Biscay and the Black Sea:</span>

<span class="sd">    &gt;&gt;&gt; def mediterranean_mask(lon: xr.DataArray, lat: xr.DataArray) -&gt; xr.DataArray:</span>
<span class="sd">    ...    # Mediterranean Sea bounding box</span>
<span class="sd">    ...    in_med = np.logical_and(-6.0327 &lt;= lon, np.logical_and(lon &lt;= 36.2173,</span>
<span class="sd">    ...                                                           np.logical_and(30.2639 &lt;= lat, lat &lt;= 45.7833)))</span>
<span class="sd">    ...    # Bay of Biscay</span>
<span class="sd">    ...    in_biscay = np.logical_and(lon &lt;= -0.1462, lat &gt;= 43.2744)</span>
<span class="sd">    ...    # Black Sea</span>
<span class="sd">    ...    in_blacksea = np.logical_and(lon &gt;= 27.4437, lat &gt;= 40.9088)</span>
<span class="sd">    ...    return np.logical_and(in_med, np.logical_not(np.logical_or(in_biscay, in_blacksea)))</span>
<span class="sd">    &gt;&gt;&gt; subset(ds, {(&quot;start_lon&quot;, &quot;start_lat&quot;): mediterranean_mask}, row_dim_name=&quot;traj&quot;)</span>
<span class="sd">    &lt;xarray.Dataset&gt; Size: ...</span>
<span class="sd">    Dimensions:                (traj: ..., obs: ...)</span>
<span class="sd">    Coordinates:</span>
<span class="sd">        id                     (traj) int64 ...</span>
<span class="sd">        time                   (obs) datetime64[ns] ...</span>
<span class="sd">    ...</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If one of the variable in a criterion is not found in the Dataset.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If one of the `criteria` key is a tuple while its associated value is not a `Callable` criterion.</span>
<span class="sd">    TypeError</span>
<span class="sd">        If variables of a `criterion` key associated to a `Callable` do not share the same dimension.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    :func:`apply_ragged`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask_row</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">row_dim_name</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">row_dim_name</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">mask_obs</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span>
        <span class="n">data</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">ds</span><span class="o">.</span><span class="n">sizes</span><span class="p">[</span><span class="n">obs_dim_name</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;bool&quot;</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">obs_dim_name</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">criteria</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">ds</span><span class="o">.</span><span class="n">dims</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">criterion</span> <span class="o">=</span> <span class="p">[</span><span class="n">ds</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">key</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">dims</span> <span class="o">==</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">criterion</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s2">&quot;Variables passed to the Callable must share the same dimension.&quot;</span>
                    <span class="p">)</span>
                <span class="n">criterion_dims</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dims</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">criterion</span> <span class="o">=</span> <span class="n">ds</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">criterion_dims</span> <span class="o">=</span> <span class="n">criterion</span><span class="o">.</span><span class="n">dims</span>

            <span class="k">if</span> <span class="n">row_dim_name</span> <span class="ow">in</span> <span class="n">criterion_dims</span><span class="p">:</span>
                <span class="n">mask_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">mask_row</span><span class="p">,</span>
                    <span class="n">_mask_var</span><span class="p">(</span>
                        <span class="n">criterion</span><span class="p">,</span> <span class="n">criteria</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="n">rowsize_var_name</span><span class="p">],</span> <span class="n">row_dim_name</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">obs_dim_name</span> <span class="ow">in</span> <span class="n">criterion_dims</span><span class="p">:</span>
                <span class="n">mask_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                    <span class="n">mask_obs</span><span class="p">,</span>
                    <span class="n">_mask_var</span><span class="p">(</span>
                        <span class="n">criterion</span><span class="p">,</span> <span class="n">criteria</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">ds</span><span class="p">[</span><span class="n">rowsize_var_name</span><span class="p">],</span> <span class="n">obs_dim_name</span>
                    <span class="p">),</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown variable &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># remove data when rows are filtered</span>
    <span class="n">traj_idx</span> <span class="o">=</span> <span class="n">rowsize_to_index</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">rowsize_var_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">mask_row</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">mask_obs</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">traj_idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">traj_idx</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># remove rows completely filtered in mask_obs</span>
    <span class="n">ids_with_mask_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">id_var_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ds</span><span class="p">[</span><span class="n">rowsize_var_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)[</span>
        <span class="n">mask_obs</span>
    <span class="p">]</span>
    <span class="n">mask_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
        <span class="n">mask_row</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="n">id_var_name</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ids_with_mask_obs</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="c1"># reset mask_obs to True if we want to keep complete rows</span>
    <span class="k">if</span> <span class="n">full_rows</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mask_row</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">mask_obs</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">traj_idx</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">traj_idx</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ids_with_mask_obs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span>
            <span class="n">ds</span><span class="p">[</span><span class="n">id_var_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">ds</span><span class="p">[</span><span class="n">rowsize_var_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
        <span class="p">)[</span><span class="n">mask_obs</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">mask_row</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No data matches the criteria; returning an empty dataset.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">xr</span><span class="o">.</span><span class="n">Dataset</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># apply the filtering for both dimensions</span>
        <span class="n">ds_sub</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">isel</span><span class="p">({</span><span class="n">row_dim_name</span><span class="p">:</span> <span class="n">mask_row</span><span class="p">,</span> <span class="n">obs_dim_name</span><span class="p">:</span> <span class="n">mask_obs</span><span class="p">})</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">unique_idx</span><span class="p">,</span> <span class="n">sorted_rowsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
            <span class="n">ids_with_mask_obs</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">ds_sub</span><span class="p">[</span><span class="n">rowsize_var_name</span><span class="p">]</span><span class="o">.</span><span class="n">values</span> <span class="o">=</span> <span class="n">sorted_rowsize</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">unique_idx</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">ds_sub</span></div>



<div class="viewcode-block" id="unpack">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.unpack.html#clouddrift.ragged.unpack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unpack</span><span class="p">(</span>
    <span class="n">ragged_array</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">rowsize</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unpack a ragged array into a list of regular arrays.</span>

<span class="sd">    Unpacking a ``np.ndarray`` ragged array is about 2 orders of magnitude</span>
<span class="sd">    faster than unpacking an ``xr.DataArray`` ragged array, so unless you need a</span>
<span class="sd">    ``DataArray`` as the result, we recommend passing ``np.ndarray`` as input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ragged_array : array-like</span>
<span class="sd">        A ragged_array to unpack</span>
<span class="sd">    rowsize : array-like</span>
<span class="sd">        An array of integers whose values is the size of each row in the ragged</span>
<span class="sd">        array</span>
<span class="sd">    rows : int or Iterable[int], optional</span>
<span class="sd">        A row or list of rows to unpack. Default is None, which unpacks all rows.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which to unpack the ragged array. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of array-likes with sizes that correspond to the values in</span>
<span class="sd">        rowsize, and types that correspond to the type of ragged_array</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    Unpacking longitude arrays from a ragged Xarray Dataset:</span>
<span class="sd">    &gt;&gt;&gt; from clouddrift.ragged import unpack</span>
<span class="sd">    &gt;&gt;&gt; from clouddrift.datasets import gdp6h</span>

<span class="sd">    &gt;&gt;&gt; ds = gdp6h()</span>

<span class="sd">    &gt;&gt;&gt; lon = unpack(ds.lon, ds[&quot;rowsize&quot;]) # return a list[xr.DataArray] (slower)</span>
<span class="sd">    &gt;&gt;&gt; lon = unpack(ds.lon.values, ds[&quot;rowsize&quot;]) # return a list[np.ndarray] (faster)</span>
<span class="sd">    &gt;&gt;&gt; first_lon = unpack(ds.lon.values, ds[&quot;rowsize&quot;], rows=0) # return only the first row</span>
<span class="sd">    &gt;&gt;&gt; first_two_lons = unpack(ds.lon.values, ds[&quot;rowsize&quot;], rows=[0, 1]) # return first two rows</span>

<span class="sd">    Looping over trajectories in a ragged Xarray Dataset to compute velocities</span>
<span class="sd">    for each:</span>

<span class="sd">    &gt;&gt;&gt; from clouddrift.kinematics import velocity_from_position</span>

<span class="sd">    &gt;&gt;&gt; for lon, lat, time in list(zip(</span>
<span class="sd">    ...     unpack(ds.lon.values, ds[&quot;rowsize&quot;]),</span>
<span class="sd">    ...     unpack(ds.lat.values, ds[&quot;rowsize&quot;]),</span>
<span class="sd">    ...     unpack(ds.time.values, ds[&quot;rowsize&quot;])</span>
<span class="sd">    ... )):</span>
<span class="sd">    ...     u, v = velocity_from_position(lon, lat, time)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indices</span> <span class="o">=</span> <span class="n">rowsize_to_index</span><span class="p">(</span><span class="n">rowsize</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">rows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rows</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">)):</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="n">rows</span><span class="p">]</span>

    <span class="n">unpacked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">ragged_array</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">unpacked</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">]</span></div>



<div class="viewcode-block" id="obs_index_to_row">
<a class="viewcode-back" href="../../_autosummary/clouddrift.ragged.obs_index_to_row.html#clouddrift.ragged.obs_index_to_row">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">obs_index_to_row</span><span class="p">(</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
    <span class="n">rowsize</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Obtain a list of row indices from a list of observation indices of a ragged array.</span>
<span class="sd">       A ragged array is constituted of rows of different sizes indicated by ``rowsize`` and is</span>
<span class="sd">       also constituted of a continuous sequence of observations with indices 0 to its length - 1.</span>
<span class="sd">       This function allows the user to obtain the row index of a given observation given its index.</span>
<span class="sd">       This answers the question: &quot;In which row is an observation located?&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    index : int or list or np.ndarray</span>
<span class="sd">        A integer observation index or a list of observation indices of a ragged array.</span>
<span class="sd">    rowsize : list or np.ndarray or xr.DataArray</span>
<span class="sd">        A sequence of row sizes of a ragged array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list</span>
<span class="sd">        A list of row indices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To obtain the row index of observation with index 5 within a ragged array of three consecutive</span>
<span class="sd">    rows of sizes 2, 4, and 3:</span>

<span class="sd">    &gt;&gt;&gt; obs_index_to_row(5, [2, 4, 3])</span>
<span class="sd">    [1]</span>

<span class="sd">    To obtain the row indices of observations with indices 0, 2, and 4 within a ragged array of three</span>
<span class="sd">    consecutive rows of sizes 2, 4, and 3:</span>

<span class="sd">    &gt;&gt;&gt; obs_index_to_row([0, 2, 4], [2, 4, 3])</span>
<span class="sd">    [0, 1, 1]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert index to list if it is not</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">):</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">index</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">index_list</span> <span class="o">=</span> <span class="n">index</span>

    <span class="c1"># if index is not a list of integers or integer-likes, raise an error</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The index must be an integer or a list of integers.&quot;</span><span class="p">)</span>

    <span class="n">rowsize_index</span> <span class="o">=</span> <span class="n">rowsize_to_index</span><span class="p">(</span><span class="n">rowsize</span><span class="p">)</span>

    <span class="c1"># test that no index is out of bounds</span>
    <span class="k">if</span> <span class="nb">any</span><span class="p">([(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">rowsize_index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">rowsize_index</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">index_list</span><span class="p">]):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Input index out of bounds based on input rowsize&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">rowsize_index</span><span class="p">,</span> <span class="n">index_list</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s2">&quot;right&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">_mask_var</span><span class="p">(</span>
    <span class="n">var</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">],</span>
    <span class="n">criterion</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">|</span> <span class="nb">list</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">|</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">|</span> <span class="nb">bool</span> <span class="o">|</span> <span class="nb">float</span> <span class="o">|</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">Callable</span><span class="p">,</span>
    <span class="n">rowsize</span><span class="p">:</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dim_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;dim_0&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the mask of a subset of the data matching a test criterion.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    var : xr.DataArray or list[xr.DataArray]</span>
<span class="sd">        DataArray or list of DataArray (only applicable if the criterion is a Callable) to be used by the criterion</span>
<span class="sd">    criterion : array-like or scalar or Callable</span>
<span class="sd">        The criterion can take four forms:</span>
<span class="sd">        - tuple: (min, max) defining a range</span>
<span class="sd">        - list, np.ndarray, or xr.DataArray: An array-like defining multiples values</span>
<span class="sd">        - scalar: value defining a single value</span>
<span class="sd">        - function: a function applied against each row using ``apply_ragged`` and returning a mask</span>
<span class="sd">    rowsize : xr.DataArray, optional</span>
<span class="sd">        List of integers specifying the number of data points in each row</span>
<span class="sd">    dim_name : str, optional</span>
<span class="sd">        Name of the masked dimension (default is &quot;dim_0&quot;)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import xarray as xr</span>
<span class="sd">    &gt;&gt;&gt; from clouddrift.ragged import _mask_var</span>

<span class="sd">    &gt;&gt;&gt; x = xr.DataArray(data=np.arange(0, 5))</span>
<span class="sd">    &gt;&gt;&gt; _mask_var(x, (2, 4))</span>
<span class="sd">    &lt;xarray.DataArray (dim_0: 5)&gt; ...</span>
<span class="sd">    array([False, False,  True,  True,  True])</span>
<span class="sd">    Dimensions without coordinates: dim_0</span>

<span class="sd">    &gt;&gt;&gt; _mask_var(x, [0, 2, 4])</span>
<span class="sd">    array([ True, False,  True, False,  True])</span>

<span class="sd">    &gt;&gt;&gt; _mask_var(x, 4)</span>
<span class="sd">    &lt;xarray.DataArray (dim_0: 5)&gt; ...</span>
<span class="sd">    array([False, False, False, False,  True])</span>
<span class="sd">    Dimensions without coordinates: dim_0</span>

<span class="sd">    &gt;&gt;&gt; rowsize = xr.DataArray(data=[2, 3])</span>
<span class="sd">    &gt;&gt;&gt; _mask_var(x, lambda arr: arr==arr[0]+1, rowsize, &quot;dim_0&quot;)</span>
<span class="sd">    &lt;xarray.DataArray (dim_0: 5)&gt; ...</span>
<span class="sd">    array([False,  True, False,  True, False])</span>
<span class="sd">    Dimensions without coordinates: dim_0</span>

<span class="sd">    &gt;&gt;&gt; y = xr.DataArray(data=np.arange(0, 5)+2)</span>
<span class="sd">    &gt;&gt;&gt; rowsize = xr.DataArray(data=[2, 3])</span>
<span class="sd">    &gt;&gt;&gt; _mask_var([x, y], lambda var1, var2: ((var1 * var2) % 2) == 0, rowsize, &quot;dim_0&quot;)</span>
<span class="sd">    &lt;xarray.DataArray (dim_0: 5)&gt; ...</span>
<span class="sd">    array([ True, False,  True, False,  True])</span>
<span class="sd">    Dimensions without coordinates: dim_0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : xr.DataArray</span>
<span class="sd">        The mask of the subset of the data matching the criteria</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">criterion</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The `var` parameter can be a `list` only if the `criterion` is a `Callable`.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>  <span class="c1"># min/max defining range</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">var</span> <span class="o">&gt;=</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">var</span> <span class="o">&lt;=</span> <span class="n">criterion</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">)):</span>
        <span class="c1"># select multiple values</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">criterion</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">criterion</span><span class="p">):</span>
        <span class="c1"># mask directly created by applying `criterion` function</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">var</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rowsize</span><span class="p">):</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">criterion</span><span class="p">(</span><span class="o">*</span><span class="n">var</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">apply_ragged</span><span class="p">(</span><span class="n">criterion</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">rowsize</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="n">dim_name</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">var</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The `Callable` function must return a masked array that matches the length of the variable to filter.&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c1"># select one specific value</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">var</span> <span class="o">==</span> <span class="n">criterion</span>
    <span class="k">return</span> <span class="n">mask</span>
</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Philippe Miron
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2022-2023, CloudDrift.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>